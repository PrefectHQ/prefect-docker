{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-docker","text":""},{"location":"#welcome","title":"Welcome!","text":"<p>Prefect integrations for working with Docker.</p> <p>Note! The <code>DockerRegistryCredentials</code> in <code>prefect-docker</code> is a unique block, separate from the <code>DockerRegistry</code> in <code>prefect</code> core. While <code>DockerRegistry</code> implements a few functionality from both <code>DockerHost</code> and <code>DockerRegistryCredentials</code> for convenience, it does not allow much configuration to interact with a Docker host.</p> <p>Do not use <code>DockerRegistry</code> with this collection. Instead, use <code>DockerHost</code> and <code>DockerRegistryCredentials</code>.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#python-setup","title":"Python setup","text":"<p>Requires an installation of Python 3.8+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda, or virtualenv.</p> <p>These tasks are designed to work with Prefect 2. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-docker</code> with <code>pip</code>:</p> <pre><code>pip install prefect-docker\n</code></pre> <p>Then, register to view the block on Prefect Cloud:</p> <pre><code>prefect block register -m prefect_docker\n</code></pre> <p>Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"#pull-image-and-create-start-log-stop-and-remove-docker-container","title":"Pull image, and create, start, log, stop, and remove Docker container","text":"<pre><code>from prefect import flow, get_run_logger\nfrom prefect_docker.images import pull_docker_image\nfrom prefect_docker.containers import (\n    create_docker_container,\n    start_docker_container,\n    get_docker_container_logs,\n    stop_docker_container,\n    remove_docker_container,\n)\n\n\n@flow\ndef docker_flow():\n    logger = get_run_logger()\n    pull_docker_image(\"prefecthq/prefect\", \"latest\")\n    container = create_docker_container(\n        image=\"prefecthq/prefect\", command=\"echo 'hello world!' &amp;&amp; sleep 60\"\n    )\n    start_docker_container(container_id=container.id)\n    logs = get_docker_container_logs(container_id=container.id)\n    logger.info(logs)\n    stop_docker_container(container_id=container.id)\n    remove_docker_container(container_id=container.id)\n    return container\n</code></pre>"},{"location":"#use-a-custom-docker-host-to-create-a-docker-container","title":"Use a custom Docker Host to create a Docker container","text":"<pre><code>from prefect import flow\nfrom prefect_docker import DockerHost\nfrom prefect_docker.containers import create_docker_container\n\n@flow\ndef create_docker_container_flow():\n    docker_host = DockerHost(\n        base_url=\"tcp://127.0.0.1:1234\",\n        max_pool_size=4\n    )\n    container = create_docker_container(\n        docker_host=docker_host,\n        image=\"prefecthq/prefect\",\n        command=\"echo 'hello world!'\"\n    )\n\ncreate_docker_container_flow()\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>If you encounter any bugs while using <code>prefect-docker</code>, feel free to open an issue in the prefect-docker repository.</p> <p>If you have any questions or issues while using <code>prefect-docker</code>, you can find help in the Prefect Slack community.</p> <p>Feel free to \u2b50\ufe0f or watch <code>prefect-docker</code> for updates too!</p>"},{"location":"#development","title":"Development","text":"<p>If you'd like to install a version of <code>prefect-docker</code> for development, clone the repository and perform an editable install with <code>pip</code>:</p> <pre><code>git clone https://github.com/PrefectHQ/prefect-docker.git\n\ncd prefect-docker/\n\npip install -e \".[dev]\"\n\n# Install linting pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"containers/","title":"Containers","text":""},{"location":"containers/#prefect_docker.containers","title":"<code>prefect_docker.containers</code>","text":"<p>Integrations with Docker Containers.</p>"},{"location":"containers/#prefect_docker.containers-classes","title":"Classes","text":""},{"location":"containers/#prefect_docker.containers-functions","title":"Functions","text":""},{"location":"containers/#prefect_docker.containers.create_docker_container","title":"<code>create_docker_container</code>  <code>async</code>","text":"<p>Create a container without starting it. Similar to docker create.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image to run.</p> required <code>command</code> <code>Optional[Union[str, List[str]]]</code> <p>The command(s) to run in the container.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The name for this container.</p> <code>None</code> <code>detach</code> <code>Optional[bool]</code> <p>Run container in the background.</p> <code>None</code> <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host.</p> <code>None</code> <code>entrypoint</code> <code>Optional[Union[str, List[str]]]</code> <p>The entrypoint for the container.</p> <code>None</code> <code>environment</code> <code>Optional[Union[Dict[str, str], List[str]]]</code> <p>Environment variables to set inside the container, as a dictionary or a list of strings in the format [\"SOMEVARIABLE=xxx\"].</p> <code>None</code> <code>**create_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.containers.create</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Container</code> <p>A Docker Container object.</p> <p>Examples:</p> <p>Create a container with the Prefect image. <pre><code>from prefect import flow\nfrom prefect_docker.containers import create_docker_container\n\n@flow\ndef create_docker_container_flow():\n    container = create_docker_container(\n        image=\"prefecthq/prefect\",\n        command=\"echo 'hello world!'\"\n    )\n\ncreate_docker_container_flow()\n</code></pre></p> Source code in <code>prefect_docker/containers.py</code> <pre><code>@task\nasync def create_docker_container(\n    image: str,\n    command: Optional[Union[str, List[str]]] = None,\n    name: Optional[str] = None,\n    detach: Optional[bool] = None,\n    entrypoint: Optional[Union[str, List[str]]] = None,\n    environment: Optional[Union[Dict[str, str], List[str]]] = None,\n    docker_host: Optional[DockerHost] = None,\n    **create_kwargs: Dict[str, Any],\n) -&gt; Container:\n    \"\"\"\n    Create a container without starting it. Similar to docker create.\n\n    Args:\n        image: The image to run.\n        command: The command(s) to run in the container.\n        name: The name for this container.\n        detach: Run container in the background.\n        docker_host: Settings for interacting with a Docker host.\n        entrypoint: The entrypoint for the container.\n        environment: Environment variables to set inside the container,\n            as a dictionary or a list of strings in the format [\"SOMEVARIABLE=xxx\"].\n        **create_kwargs: Additional keyword arguments to pass to\n            [`client.containers.create`](https://docker-py.readthedocs.io/en/stable/containers.html#docker.models.containers.ContainerCollection.create).\n\n    Returns:\n        A Docker Container object.\n\n    Examples:\n        Create a container with the Prefect image.\n        ```python\n        from prefect import flow\n        from prefect_docker.containers import create_docker_container\n\n        @flow\n        def create_docker_container_flow():\n            container = create_docker_container(\n                image=\"prefecthq/prefect\",\n                command=\"echo 'hello world!'\"\n            )\n\n        create_docker_container_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    with (docker_host or DockerHost()).get_client() as client:\n        logger.info(f\"Creating container with {image!r} image.\")\n        container = await run_sync_in_worker_thread(\n            client.containers.create,\n            image=image,\n            command=command,\n            name=name,\n            detach=detach,\n            entrypoint=entrypoint,\n            environment=environment,\n            **create_kwargs,\n        )\n    return container\n</code></pre>"},{"location":"containers/#prefect_docker.containers.get_docker_container_logs","title":"<code>get_docker_container_logs</code>  <code>async</code>","text":"<p>Get logs from this container. Similar to the docker logs command.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID to pull logs from.</p> required <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host.</p> <code>None</code> <code>**logs_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.containers.get(container_id).logs</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The Container's logs.</p> <p>Examples:</p> <p>Gets logs from a container with an ID that starts with \"c157\". <pre><code>from prefect import flow\nfrom prefect_docker.containers import get_docker_container_logs\n\n@flow\ndef get_docker_container_logs_flow():\n    logs = get_docker_container_logs(container_id=\"c157\")\n    return logs\n\nget_docker_container_logs_flow()\n</code></pre></p> Source code in <code>prefect_docker/containers.py</code> <pre><code>@task\nasync def get_docker_container_logs(\n    container_id: str,\n    docker_host: Optional[DockerHost] = None,\n    **logs_kwargs: Dict[str, Any],\n) -&gt; str:\n    \"\"\"\n    Get logs from this container. Similar to the docker logs command.\n\n    Args:\n        container_id: The container ID to pull logs from.\n        docker_host: Settings for interacting with a Docker host.\n        **logs_kwargs: Additional keyword arguments to pass to\n            [`client.containers.get(container_id).logs`](https://docker-py.readthedocs.io/en/stable/containers.html#docker.models.containers.Container.logs).\n\n    Returns:\n        The Container's logs.\n\n    Examples:\n        Gets logs from a container with an ID that starts with \"c157\".\n        ```python\n        from prefect import flow\n        from prefect_docker.containers import get_docker_container_logs\n\n        @flow\n        def get_docker_container_logs_flow():\n            logs = get_docker_container_logs(container_id=\"c157\")\n            return logs\n\n        get_docker_container_logs_flow()\n        ```\n\n    \"\"\"\n    logger = get_run_logger()\n\n    with (docker_host or DockerHost()).get_client() as client:\n        container = await run_sync_in_worker_thread(client.containers.get, container_id)\n        logger.info(f\"Retrieving logs from {container.id!r} container.\")\n        logs = await run_sync_in_worker_thread(container.logs, **logs_kwargs)\n\n    return logs.decode()\n</code></pre>"},{"location":"containers/#prefect_docker.containers.remove_docker_container","title":"<code>remove_docker_container</code>  <code>async</code>","text":"<p>Remove this container. Similar to the docker rm command.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID to remove.</p> required <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host.</p> <code>None</code> <code>**remove_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.containers.get(container_id).remove</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Container</code> <p>The Docker Container object.</p> <p>Examples:</p> <p>Removes a container with an ID that starts wtih \"c157\". <pre><code>from prefect import flow\nfrom prefect_docker.containers import remove_docker_container\n\n@flow\ndef remove_docker_container_flow():\n    container = remove_docker_container(container_id=\"c157\")\n    return container\n\nremove_docker_container()\n</code></pre></p> Source code in <code>prefect_docker/containers.py</code> <pre><code>@task\nasync def remove_docker_container(\n    container_id: str,\n    docker_host: Optional[DockerHost] = None,\n    **remove_kwargs: Dict[str, Any],\n) -&gt; Container:\n    \"\"\"\n    Remove this container. Similar to the docker rm command.\n\n    Args:\n        container_id: The container ID to remove.\n        docker_host: Settings for interacting with a Docker host.\n        **remove_kwargs: Additional keyword arguments to pass to\n            [`client.containers.get(container_id).remove`](https://docker-py.readthedocs.io/en/stable/containers.html#docker.models.containers.Container.remove).\n\n    Returns:\n        The Docker Container object.\n\n    Examples:\n        Removes a container with an ID that starts wtih \"c157\".\n        ```python\n        from prefect import flow\n        from prefect_docker.containers import remove_docker_container\n\n        @flow\n        def remove_docker_container_flow():\n            container = remove_docker_container(container_id=\"c157\")\n            return container\n\n        remove_docker_container()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    with (docker_host or DockerHost()).get_client() as client:\n        container = await run_sync_in_worker_thread(client.containers.get, container_id)\n        logger.info(f\"Removing container {container.id!r}.\")\n        await run_sync_in_worker_thread(container.remove, **remove_kwargs)\n\n    return container\n</code></pre>"},{"location":"containers/#prefect_docker.containers.start_docker_container","title":"<code>start_docker_container</code>  <code>async</code>","text":"<p>Start this container. Similar to the docker start command.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID to start.</p> required <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host.</p> <code>None</code> <code>**start_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.containers.get(container_id).start</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Container</code> <p>The Docker Container object.</p> <p>Examples:</p> <p>Start a container with an ID that starts wtih \"c157\". <pre><code>from prefect import flow\nfrom prefect_docker.containers import start_docker_container\n\n@flow\ndef start_docker_container_flow():\n    container = start_docker_container(container_id=\"c157\")\n    return container\n\nstart_docker_container_flow()\n</code></pre></p> Source code in <code>prefect_docker/containers.py</code> <pre><code>@task\nasync def start_docker_container(\n    container_id: str,\n    docker_host: Optional[DockerHost] = None,\n    **start_kwargs: Dict[str, Any],\n) -&gt; Container:\n    \"\"\"\n    Start this container. Similar to the docker start command.\n\n    Args:\n        container_id: The container ID to start.\n        docker_host: Settings for interacting with a Docker host.\n        **start_kwargs: Additional keyword arguments to pass to\n            [`client.containers.get(container_id).start`](https://docker-py.readthedocs.io/en/stable/containers.html#docker.models.containers.Container.start).\n\n    Returns:\n        The Docker Container object.\n\n    Examples:\n        Start a container with an ID that starts wtih \"c157\".\n        ```python\n        from prefect import flow\n        from prefect_docker.containers import start_docker_container\n\n        @flow\n        def start_docker_container_flow():\n            container = start_docker_container(container_id=\"c157\")\n            return container\n\n        start_docker_container_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    with (docker_host or DockerHost()).get_client() as client:\n        container = await run_sync_in_worker_thread(client.containers.get, container_id)\n        logger.info(f\"Starting container {container.id!r}.\")\n        await run_sync_in_worker_thread(container.start, **start_kwargs)\n\n    return container\n</code></pre>"},{"location":"containers/#prefect_docker.containers.stop_docker_container","title":"<code>stop_docker_container</code>  <code>async</code>","text":"<p>Stops a container. Similar to the docker stop command.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID to stop.</p> required <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host.</p> <code>None</code> <code>**stop_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.containers.get(container_id).stop</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Container</code> <p>The Docker Container object.</p> <p>Examples:</p> <p>Stop a container with an ID that starts wtih \"c157\". <pre><code>from prefect import flow\nfrom prefect_docker.containers import stop_docker_container\n\n@flow\ndef stop_docker_container_flow():\n    container = stop_docker_container(container_id=\"c157\")\n    return container\n\nstop_docker_container_flow()\n</code></pre></p> Source code in <code>prefect_docker/containers.py</code> <pre><code>@task\nasync def stop_docker_container(\n    container_id: str,\n    docker_host: Optional[DockerHost] = None,\n    **stop_kwargs: Dict[str, Any],\n) -&gt; Container:\n    \"\"\"\n    Stops a container. Similar to the docker stop command.\n\n    Args:\n        container_id: The container ID to stop.\n        docker_host: Settings for interacting with a Docker host.\n        **stop_kwargs: Additional keyword arguments to pass to\n            [`client.containers.get(container_id).stop`](https://docker-py.readthedocs.io/en/stable/containers.html#docker.models.containers.Container.stop).\n\n    Returns:\n        The Docker Container object.\n\n    Examples:\n        Stop a container with an ID that starts wtih \"c157\".\n        ```python\n        from prefect import flow\n        from prefect_docker.containers import stop_docker_container\n\n        @flow\n        def stop_docker_container_flow():\n            container = stop_docker_container(container_id=\"c157\")\n            return container\n\n        stop_docker_container_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n\n    with (docker_host or DockerHost()).get_client() as client:\n        container = await run_sync_in_worker_thread(client.containers.get, container_id)\n        logger.info(f\"Stopping container {container.id!r}.\")\n        await run_sync_in_worker_thread(container.stop, **stop_kwargs)\n\n    return container\n</code></pre>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#prefect_docker.credentials","title":"<code>prefect_docker.credentials</code>","text":"<p>Module containing docker credentials.</p>"},{"location":"credentials/#prefect_docker.credentials-classes","title":"Classes","text":""},{"location":"credentials/#prefect_docker.credentials.DockerRegistryCredentials","title":"<code>DockerRegistryCredentials</code>","text":"<p>             Bases: <code>Block</code></p> <p>Block used to manage credentials for interacting with a Docker Registry.</p> <p>Examples:</p> <p>Log into Docker Registry. <pre><code>from prefect_docker import DockerHost, DockerRegistryCredentials\n\ndocker_host = DockerHost()\ndocker_registry_credentials = DockerRegistryCredentials(\n    username=\"my_username\",\n    password=\"my_password\",\n    registry_url=\"registry.hub.docker.com\",\n)\nwith docker_host.get_client() as client:\n    docker_registry_credentials.login(client)\n</code></pre></p> Source code in <code>prefect_docker/credentials.py</code> <pre><code>class DockerRegistryCredentials(Block):\n    \"\"\"\n    Block used to manage credentials for interacting with a Docker Registry.\n\n    Examples:\n        Log into Docker Registry.\n        ```python\n        from prefect_docker import DockerHost, DockerRegistryCredentials\n\n        docker_host = DockerHost()\n        docker_registry_credentials = DockerRegistryCredentials(\n            username=\"my_username\",\n            password=\"my_password\",\n            registry_url=\"registry.hub.docker.com\",\n        )\n        with docker_host.get_client() as client:\n            docker_registry_credentials.login(client)\n        ```\n    \"\"\"\n\n    _block_type_name = \"Docker Registry Credentials\"\n    _logo_url = \"https://cdn.sanity.io/images/3ugk85nk/production/14a315b79990200db7341e42553e23650b34bb96-250x250.png\"  # noqa\n    _description = \"Store credentials for interacting with a Docker Registry.\"\n\n    username: str = Field(\n        default=..., description=\"The username to log into the registry with.\"\n    )\n    password: SecretStr = Field(\n        default=..., description=\"The password to log into the registry with.\"\n    )\n    registry_url: str = Field(\n        default=...,\n        description=(\n            'The URL to the registry. Generally, \"http\" or \"https\" can be omitted.'\n        ),\n        example=\"index.docker.io\",\n    )\n    reauth: bool = Field(\n        default=True,\n        description=\"Whether or not to reauthenticate on each interaction.\",\n    )\n\n    async def login(self, client: docker.DockerClient):\n        \"\"\"\n        Authenticates a given Docker client with the configured Docker registry.\n\n        Args:\n            client: A Docker Client.\n        \"\"\"\n        logger = get_run_logger()\n        logger.debug(f\"Logging into {self.registry_url}.\")\n        await run_sync_in_worker_thread(\n            client.login,\n            username=self.username,\n            password=self.password.get_secret_value(),\n            registry=self.registry_url,\n            # See https://github.com/docker/docker-py/issues/2256 for information on\n            # the default value for reauth.\n            reauth=self.reauth,\n        )\n</code></pre>"},{"location":"credentials/#prefect_docker.credentials.DockerRegistryCredentials-functions","title":"Functions","text":""},{"location":"credentials/#prefect_docker.credentials.DockerRegistryCredentials.login","title":"<code>login</code>  <code>async</code>","text":"<p>Authenticates a given Docker client with the configured Docker registry.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>DockerClient</code> <p>A Docker Client.</p> required Source code in <code>prefect_docker/credentials.py</code> <pre><code>async def login(self, client: docker.DockerClient):\n    \"\"\"\n    Authenticates a given Docker client with the configured Docker registry.\n\n    Args:\n        client: A Docker Client.\n    \"\"\"\n    logger = get_run_logger()\n    logger.debug(f\"Logging into {self.registry_url}.\")\n    await run_sync_in_worker_thread(\n        client.login,\n        username=self.username,\n        password=self.password.get_secret_value(),\n        registry=self.registry_url,\n        # See https://github.com/docker/docker-py/issues/2256 for information on\n        # the default value for reauth.\n        reauth=self.reauth,\n    )\n</code></pre>"},{"location":"host/","title":"Host","text":""},{"location":"host/#prefect_docker.host","title":"<code>prefect_docker.host</code>","text":"<p>Module containing Docker host settings.</p>"},{"location":"host/#prefect_docker.host-classes","title":"Classes","text":""},{"location":"host/#prefect_docker.host.DockerHost","title":"<code>DockerHost</code>","text":"<p>             Bases: <code>Block</code></p> <p>Block used to manage settings for interacting with a Docker host.</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <code>Optional[str]</code> <p>URL to the Docker server, e.g. <code>unix:///var/run/docker.sock</code> or <code>tcp://127.0.0.1:1234</code>. If this is not set, the client will be configured from environment variables.</p> <code>version</code> <code>str</code> <p>The version of the API to use. Set to auto to automatically detect the server's version.</p> <code>timeout</code> <code>Optional[int]</code> <p>Default timeout for API calls, in seconds.</p> <code>max_pool_size</code> <code>Optional[int]</code> <p>The maximum number of connections to save in the pool.</p> <code>client_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>docker.from_env()</code> or <code>DockerClient</code>.</p> <p>Examples:</p> <p>Get a Docker Host client. <pre><code>from prefect_docker import DockerHost\n\ndocker_host = DockerHost(\nbase_url=\"tcp://127.0.0.1:1234\",\n    max_pool_size=4\n)\nwith docker_host.get_client() as client:\n    ... # Use the client for Docker operations\n</code></pre></p> Source code in <code>prefect_docker/host.py</code> <pre><code>class DockerHost(Block):\n    \"\"\"\n    Block used to manage settings for interacting with a Docker host.\n\n    Attributes:\n        base_url: URL to the Docker server, e.g. `unix:///var/run/docker.sock`\n            or `tcp://127.0.0.1:1234`. If this is not set, the client will\n            be configured from environment variables.\n        version: The version of the API to use. Set to auto to\n            automatically detect the server's version.\n        timeout: Default timeout for API calls, in seconds.\n        max_pool_size: The maximum number of connections to save in the pool.\n        client_kwargs: Additional keyword arguments to pass to\n            `docker.from_env()` or `DockerClient`.\n\n    Examples:\n        Get a Docker Host client.\n        ```python\n        from prefect_docker import DockerHost\n\n        docker_host = DockerHost(\n        base_url=\"tcp://127.0.0.1:1234\",\n            max_pool_size=4\n        )\n        with docker_host.get_client() as client:\n            ... # Use the client for Docker operations\n        ```\n    \"\"\"\n\n    _block_type_name = \"Docker Host\"\n    _logo_url = \"https://cdn.sanity.io/images/3ugk85nk/production/14a315b79990200db7341e42553e23650b34bb96-250x250.png\"  # noqa\n    _description = \"Store settings for interacting with a Docker host.\"\n\n    base_url: Optional[str] = Field(\n        default=None,\n        description=\"URL to the Docker host.\",\n        title=\"Base URL\",\n        example=\"unix:///var/run/docker.sock\",\n    )\n    version: str = Field(default=\"auto\", description=\"The version of the API to use\")\n    timeout: Optional[int] = Field(\n        default=None, description=\"Default timeout for API calls, in seconds.\"\n    )\n    max_pool_size: Optional[int] = Field(\n        default=None,\n        description=\"The maximum number of connections to save in the pool.\",\n    )\n    client_kwargs: Dict[str, Any] = Field(\n        default_factory=dict,\n        title=\"Additional Configuration\",\n        description=(\n            \"Additional keyword arguments to pass to \"\n            \"`docker.from_env()` or `DockerClient`.\"\n        ),\n    )\n\n    def get_client(self) -&gt; docker.DockerClient:\n        \"\"\"\n        Gets a Docker Client to communicate with a Docker host.\n\n        Returns:\n            A Docker Client.\n        \"\"\"\n        logger = get_run_logger()\n        client_kwargs = {\n            \"version\": self.version,\n            \"timeout\": self.timeout,\n            \"max_pool_size\": self.max_pool_size,\n            **self.client_kwargs,\n        }\n        client_kwargs = {\n            key: value for key, value in client_kwargs.items() if value is not None\n        }\n        if self.base_url is None:\n            logger.debug(\n                f\"Creating a Docker client from \"\n                f\"environment variables, using {self.version} version.\"\n            )\n            client = _ContextManageableDockerClient.from_env(**client_kwargs)\n        else:\n            logger.debug(\n                f\"Creating a Docker client to {self.base_url} \"\n                f\"using {self.version} version.\"\n            )\n            client = _ContextManageableDockerClient(\n                base_url=self.base_url, **client_kwargs\n            )\n        return client\n</code></pre>"},{"location":"host/#prefect_docker.host.DockerHost-functions","title":"Functions","text":""},{"location":"host/#prefect_docker.host.DockerHost.get_client","title":"<code>get_client</code>","text":"<p>Gets a Docker Client to communicate with a Docker host.</p> <p>Returns:</p> Type Description <code>DockerClient</code> <p>A Docker Client.</p> Source code in <code>prefect_docker/host.py</code> <pre><code>def get_client(self) -&gt; docker.DockerClient:\n    \"\"\"\n    Gets a Docker Client to communicate with a Docker host.\n\n    Returns:\n        A Docker Client.\n    \"\"\"\n    logger = get_run_logger()\n    client_kwargs = {\n        \"version\": self.version,\n        \"timeout\": self.timeout,\n        \"max_pool_size\": self.max_pool_size,\n        **self.client_kwargs,\n    }\n    client_kwargs = {\n        key: value for key, value in client_kwargs.items() if value is not None\n    }\n    if self.base_url is None:\n        logger.debug(\n            f\"Creating a Docker client from \"\n            f\"environment variables, using {self.version} version.\"\n        )\n        client = _ContextManageableDockerClient.from_env(**client_kwargs)\n    else:\n        logger.debug(\n            f\"Creating a Docker client to {self.base_url} \"\n            f\"using {self.version} version.\"\n        )\n        client = _ContextManageableDockerClient(\n            base_url=self.base_url, **client_kwargs\n        )\n    return client\n</code></pre>"},{"location":"images/","title":"Images","text":""},{"location":"images/#prefect_docker.images","title":"<code>prefect_docker.images</code>","text":"<p>Integrations with Docker Images.</p>"},{"location":"images/#prefect_docker.images-classes","title":"Classes","text":""},{"location":"images/#prefect_docker.images-functions","title":"Functions","text":""},{"location":"images/#prefect_docker.images.pull_docker_image","title":"<code>pull_docker_image</code>  <code>async</code>","text":"<p>Pull an image of the given name and return it. Similar to the docker pull command.</p> <p>If all_tags is set, the tag parameter is ignored and all image tags will be pulled.</p> <p>Parameters:</p> Name Type Description Default <code>repository</code> <code>str</code> <p>The repository to pull.</p> required <code>tag</code> <code>Optional[str]</code> <p>The tag to pull; if not provided, it is set to latest.</p> <code>None</code> <code>platform</code> <code>Optional[str]</code> <p>Platform in the format os[/arch[/variant]].</p> <code>None</code> <code>all_tags</code> <code>bool</code> <p>Pull all image tags which will return a list of Images.</p> <code>False</code> <code>docker_host</code> <code>Optional[DockerHost]</code> <p>Settings for interacting with a Docker host; if not provided, will automatically instantiate a <code>DockerHost</code> from env.</p> <code>None</code> <code>docker_registry_credentials</code> <code>Optional[DockerRegistryCredentials]</code> <p>Docker credentials used to log in to a registry before pulling the image.</p> <code>None</code> <code>**pull_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to <code>client.images.pull</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Image, List[Image]]</code> <p>The image that has been pulled, or a list of images if <code>all_tags</code> is <code>True</code>.</p> <p>Examples:</p> <p>Pull prefecthq/prefect image with the tag latest-python3.10. <pre><code>from prefect import flow\nfrom prefect_docker.images import pull_docker_image\n\n@flow\ndef pull_docker_image_flow():\n    image = pull_docker_image(\n        repository=\"prefecthq/prefect\",\n        tag=\"latest-python3.10\"\n    )\n    return image\n\npull_docker_image_flow()\n</code></pre></p> Source code in <code>prefect_docker/images.py</code> <pre><code>@task\nasync def pull_docker_image(\n    repository: str,\n    tag: Optional[str] = None,\n    platform: Optional[str] = None,\n    all_tags: bool = False,\n    docker_host: Optional[DockerHost] = None,\n    docker_registry_credentials: Optional[DockerRegistryCredentials] = None,\n    **pull_kwargs: Dict[str, Any],\n) -&gt; Union[Image, List[Image]]:\n    \"\"\"\n    Pull an image of the given name and return it. Similar to the docker pull command.\n\n    If all_tags is set, the tag parameter is ignored and all image tags will be pulled.\n\n    Args:\n        repository: The repository to pull.\n        tag: The tag to pull; if not provided, it is set to latest.\n        platform: Platform in the format os[/arch[/variant]].\n        all_tags: Pull all image tags which will return a list of Images.\n        docker_host: Settings for interacting with a Docker host; if not\n            provided, will automatically instantiate a `DockerHost` from env.\n        docker_registry_credentials: Docker credentials used to log in to\n            a registry before pulling the image.\n        **pull_kwargs: Additional keyword arguments to pass to `client.images.pull`.\n\n    Returns:\n        The image that has been pulled, or a list of images if `all_tags` is `True`.\n\n    Examples:\n        Pull prefecthq/prefect image with the tag latest-python3.10.\n        ```python\n        from prefect import flow\n        from prefect_docker.images import pull_docker_image\n\n        @flow\n        def pull_docker_image_flow():\n            image = pull_docker_image(\n                repository=\"prefecthq/prefect\",\n                tag=\"latest-python3.10\"\n            )\n            return image\n\n        pull_docker_image_flow()\n        ```\n    \"\"\"\n    logger = get_run_logger()\n    if tag and all_tags:\n        raise ValueError(\"Cannot pass `tags` and `all_tags` together\")\n\n    pull_kwargs = {\n        \"repository\": repository,\n        \"tag\": tag,\n        \"platform\": platform,\n        \"all_tags\": all_tags,\n        **pull_kwargs,\n    }\n    pull_kwargs = {\n        key: value for key, value in pull_kwargs.items() if value is not None\n    }\n\n    with (docker_host or DockerHost()).get_client() as client:\n        if docker_registry_credentials is not None:\n            await docker_registry_credentials.login(client=client)\n\n        if tag:\n            logger.info(f\"Pulling image: {repository}:{tag}.\")\n        elif all_tags:\n            logger.info(f\"Pulling all images from: {repository}\")\n\n        image = await run_sync_in_worker_thread(client.images.pull, **pull_kwargs)\n\n    return image\n</code></pre>"},{"location":"worker/","title":"Worker","text":""},{"location":"worker/#prefect_docker.worker","title":"<code>prefect_docker.worker</code>","text":"<p>Module containing the Docker worker used for executing flow runs as Docker containers.</p> <p>To start a Docker worker, run the following command:</p> <pre><code>prefect worker start --pool 'my-work-pool' --type docker\n</code></pre> <p>Replace <code>my-work-pool</code> with the name of the work pool you want the worker to poll for flow runs.</p> <p>For more information about work pools and workers, checkout out the Prefect docs.</p>"},{"location":"worker/#prefect_docker.worker-classes","title":"Classes","text":""},{"location":"worker/#prefect_docker.worker.DockerWorker","title":"<code>DockerWorker</code>","text":"<p>             Bases: <code>BaseWorker</code></p> <p>Prefect worker that executes flow runs within Docker containers.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>class DockerWorker(BaseWorker):\n    \"\"\"Prefect worker that executes flow runs within Docker containers.\"\"\"\n\n    type = \"docker\"\n    job_configuration = DockerWorkerJobConfiguration\n    _description = (\n        \"Execute flow runs within Docker containers. Works well for managing flow \"\n        \"execution environments via Docker images. Requires access to a running \"\n        \"Docker daemon.\"\n    )\n    _display_name = \"Docker\"\n    _documentation_url = \"https://prefecthq.github.io/prefect-docker/worker/\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/2IfXXfMq66mrzJBDFFCHTp/6d8f320d9e4fc4393f045673d61ab612/Moby-logo.png?h=250\"  # noqa\n\n    def __init__(self, *args: Any, test_mode: bool = None, **kwargs: Any) -&gt; None:\n        if test_mode is None:\n            self.test_mode = bool(os.getenv(\"PREFECT_DOCKER_TEST_MODE\", False))\n        else:\n            self.test_mode = test_mode\n        super().__init__(*args, **kwargs)\n\n    async def setup(self):\n        if not self.test_mode:\n            self._client = get_client()\n            if self._client.server_type == ServerType.EPHEMERAL:\n                raise RuntimeError(\n                    \"Docker worker cannot be used with an ephemeral server. Please set\"\n                    \" PREFECT_API_URL to the URL for your Prefect API instance. You\"\n                    \" can use a local Prefect API instance by running `prefect server\"\n                    \" start`.\"\n                )\n\n        return await super().setup()\n\n    async def run(\n        self,\n        flow_run: \"FlowRun\",\n        configuration: BaseJobConfiguration,\n        task_status: Optional[anyio.abc.TaskStatus] = None,\n    ) -&gt; BaseWorkerResult:\n        \"\"\"\n        Executes a flow run within a Docker container and waits for the flow run\n        to complete.\n        \"\"\"\n        # The `docker` library uses requests instead of an async http library so it must\n        # be run in a thread to avoid blocking the event loop.\n        container, created_event = await run_sync_in_worker_thread(\n            self._create_and_start_container, configuration\n        )\n        container_pid = self._get_infrastructure_pid(container_id=container.id)\n\n        # Mark as started and return the infrastructure id\n        if task_status:\n            task_status.started(container_pid)\n\n        # Monitor the container\n        container = await run_sync_in_worker_thread(\n            self._watch_container_safe, container, configuration, created_event\n        )\n\n        exit_code = container.attrs[\"State\"].get(\"ExitCode\")\n        return DockerWorkerResult(\n            status_code=exit_code if exit_code is not None else -1,\n            identifier=container_pid,\n        )\n\n    async def kill_infrastructure(\n        self,\n        infrastructure_pid: str,\n        configuration: DockerWorkerJobConfiguration,\n        grace_seconds: int = 30,\n    ):\n        \"\"\"\n        Stops a container for a cancelled flow run based on the provided infrastructure\n        PID.\n        \"\"\"\n        docker_client = self._get_client()\n\n        base_url, container_id = self._parse_infrastructure_pid(infrastructure_pid)\n        if docker_client.api.base_url != base_url:\n            raise InfrastructureNotAvailable(\n                \"\".join(\n                    [\n                        (\n                            f\"Unable to stop container {container_id!r}: the current\"\n                            \" Docker API \"\n                        ),\n                        (\n                            f\"URL {docker_client.api.base_url!r} does not match the\"\n                            \" expected \"\n                        ),\n                        f\"API base URL {base_url}.\",\n                    ]\n                )\n            )\n        await run_sync_in_worker_thread(\n            self._stop_container, container_id, docker_client, grace_seconds\n        )\n\n    def _stop_container(\n        self,\n        container_id: str,\n        client: \"DockerClient\",\n        grace_seconds: int = 30,\n    ):\n        try:\n            container = client.containers.get(container_id=container_id)\n        except docker.errors.NotFound:\n            raise InfrastructureNotFound(\n                f\"Unable to stop container {container_id!r}: The container was not\"\n                \" found.\"\n            )\n\n        container.stop(timeout=grace_seconds)\n\n    def _get_client(self):\n        \"\"\"Returns a docker client.\"\"\"\n        try:\n            with warnings.catch_warnings():\n                # Silence warnings due to use of deprecated methods within dockerpy\n                # See https://github.com/docker/docker-py/pull/2931\n                warnings.filterwarnings(\n                    \"ignore\",\n                    message=\"distutils Version classes are deprecated.*\",\n                    category=DeprecationWarning,\n                )\n\n                docker_client = docker.from_env()\n\n        except docker.errors.DockerException as exc:\n            raise RuntimeError(\"Could not connect to Docker.\") from exc\n\n        return docker_client\n\n    def _get_infrastructure_pid(self, container_id: str) -&gt; str:\n        \"\"\"Generates a Docker infrastructure_pid string in the form of\n        `&lt;docker_host_base_url&gt;:&lt;container_id&gt;`.\n        \"\"\"\n        docker_client = self._get_client()\n        base_url = docker_client.api.base_url\n        docker_client.close()\n        return f\"{base_url}:{container_id}\"\n\n    def _parse_infrastructure_pid(self, infrastructure_pid: str) -&gt; Tuple[str, str]:\n        \"\"\"Splits a Docker infrastructure_pid into its component parts\"\"\"\n\n        # base_url can contain `:` so we only want the last item of the split\n        base_url, container_id = infrastructure_pid.rsplit(\":\", 1)\n        return base_url, str(container_id)\n\n    def _build_container_settings(\n        self,\n        docker_client: \"DockerClient\",\n        configuration: DockerWorkerJobConfiguration,\n    ) -&gt; Dict:\n        \"\"\"Builds a dictionary of container settings to pass to the Docker API.\"\"\"\n        network_mode = configuration.get_network_mode()\n        return dict(\n            image=configuration.image,\n            network=configuration.networks[0] if configuration.networks else None,\n            network_mode=network_mode,\n            command=configuration.command,\n            environment=configuration.env,\n            auto_remove=configuration.auto_remove,\n            labels=configuration.labels,\n            extra_hosts=configuration.get_extra_hosts(docker_client),\n            name=configuration.name,\n            volumes=configuration.volumes,\n            mem_limit=configuration.mem_limit,\n            memswap_limit=configuration.memswap_limit,\n            privileged=configuration.privileged,\n        )\n\n    def _create_and_start_container(\n        self, configuration: DockerWorkerJobConfiguration\n    ) -&gt; Tuple[\"Container\", Event]:\n        \"\"\"Creates and starts a Docker container.\"\"\"\n        docker_client = self._get_client()\n        if configuration.registry_credentials:\n            self._logger.info(\"Logging into Docker registry...\")\n            docker_client.login(\n                username=configuration.registry_credentials.username,\n                password=configuration.registry_credentials.password.get_secret_value(),\n                registry=configuration.registry_credentials.registry_url,\n                reauth=configuration.registry_credentials.reauth,\n            )\n        container_settings = self._build_container_settings(\n            docker_client, configuration\n        )\n\n        if self._should_pull_image(docker_client, configuration=configuration):\n            self._logger.info(f\"Pulling image {configuration.image!r}...\")\n            self._pull_image(docker_client, configuration)\n\n        try:\n            container = self._create_container(docker_client, **container_settings)\n        except Exception as exc:\n            self._emit_container_creation_failed_event(configuration)\n            raise exc\n\n        created_event = self._emit_container_status_change_event(\n            container, configuration\n        )\n\n        # Add additional networks after the container is created; only one network can\n        # be attached at creation time\n        if len(configuration.networks) &gt; 1:\n            for network_name in configuration.networks[1:]:\n                network = docker_client.networks.get(network_name)\n                network.connect(container)\n\n        # Start the container\n        container.start()\n\n        docker_client.close()\n\n        return container, created_event\n\n    def _watch_container_safe(\n        self,\n        container: \"Container\",\n        configuration: DockerWorkerJobConfiguration,\n        created_event: Event,\n    ) -&gt; \"Container\":\n        \"\"\"Watches a container for completion, handling any errors that may occur.\"\"\"\n        # Monitor the container capturing the latest snapshot while capturing\n        # not found errors\n        docker_client = self._get_client()\n\n        try:\n            seen_statuses = {container.status}\n            last_event = created_event\n            for latest_container in self._watch_container(\n                docker_client, container.id, configuration\n            ):\n                container = latest_container\n                if container.status not in seen_statuses:\n                    seen_statuses.add(container.status)\n                    last_event = self._emit_container_status_change_event(\n                        container, configuration, last_event=last_event\n                    )\n\n        except docker.errors.NotFound:\n            # The container was removed during watching\n            self._logger.warning(\n                f\"Docker container {container.name} was removed before we could wait \"\n                \"for its completion.\"\n            )\n        finally:\n            docker_client.close()\n\n        return container\n\n    def _watch_container(\n        self,\n        docker_client: \"DockerClient\",\n        container_id: str,\n        configuration: DockerWorkerJobConfiguration,\n    ) -&gt; Generator[None, None, \"Container\"]:\n        \"\"\"\n        Watches a container for completion, yielding the latest container\n        snapshot on each iteration.\n        \"\"\"\n        container: \"Container\" = docker_client.containers.get(container_id)\n\n        status = container.status\n        self._logger.info(\n            f\"Docker container {container.name!r} has status {container.status!r}\"\n        )\n        yield container\n\n        if configuration.stream_output:\n            try:\n                for log in container.logs(stream=True):\n                    log: bytes\n                    print(log.decode().rstrip())\n            except docker.errors.APIError as exc:\n                if \"marked for removal\" in str(exc):\n                    self._logger.warning(\n                        f\"Docker container {container.name} was marked for removal\"\n                        \" before logs could be retrieved. Output will not be\"\n                        \" streamed. \"\n                    )\n                else:\n                    self._logger.exception(\n                        \"An unexpected Docker API error occured while streaming output \"\n                        f\"from container {container.name}.\"\n                    )\n\n            container.reload()\n            if container.status != status:\n                self._logger.info(\n                    f\"Docker container {container.name!r} has status\"\n                    f\" {container.status!r}\"\n                )\n            yield container\n\n        container.wait()\n        self._logger.info(\n            f\"Docker container {container.name!r} has status {container.status!r}\"\n        )\n        yield container\n\n    def _should_pull_image(\n        self, docker_client: \"DockerClient\", configuration: DockerWorkerJobConfiguration\n    ) -&gt; bool:\n        \"\"\"\n        Decide whether we need to pull the Docker image.\n        \"\"\"\n        image_pull_policy = configuration._determine_image_pull_policy()\n\n        if image_pull_policy is ImagePullPolicy.ALWAYS:\n            return True\n        elif image_pull_policy is ImagePullPolicy.NEVER:\n            return False\n        elif image_pull_policy is ImagePullPolicy.IF_NOT_PRESENT:\n            try:\n                # NOTE: images.get() wants the tag included with the image\n                # name, while images.pull() wants them split.\n                docker_client.images.get(configuration.image)\n            except docker.errors.ImageNotFound:\n                self._logger.debug(\n                    f\"Could not find Docker image locally: {configuration.image}\"\n                )\n                return True\n        return False\n\n    def _pull_image(\n        self, docker_client: \"DockerClient\", configuration: DockerWorkerJobConfiguration\n    ):\n        \"\"\"\n        Pull the image we're going to use to create the container.\n        \"\"\"\n        image, tag = parse_image_tag(configuration.image)\n\n        return docker_client.images.pull(image, tag)\n\n    def _create_container(self, docker_client: \"DockerClient\", **kwargs) -&gt; \"Container\":\n        \"\"\"\n        Create a docker container with retries on name conflicts.\n\n        If the container already exists with the given name, an incremented index is\n        added.\n        \"\"\"\n        # Create the container with retries on name conflicts (with an incremented idx)\n        index = 0\n        container = None\n        name = original_name = kwargs.pop(\"name\")\n\n        while not container:\n            try:\n                display_name = repr(name) if name else \"with auto-generated name\"\n                self._logger.info(f\"Creating Docker container {display_name}...\")\n                container = docker_client.containers.create(name=name, **kwargs)\n            except docker.errors.APIError as exc:\n                if \"Conflict\" in str(exc) and \"container name\" in str(exc):\n                    self._logger.info(\n                        f\"Docker container name {display_name} already exists; \"\n                        \"retrying...\"\n                    )\n                    index += 1\n                    name = f\"{original_name}-{index}\"\n                else:\n                    raise\n\n        self._logger.info(\n            f\"Docker container {container.name!r} has status {container.status!r}\"\n        )\n        return container\n\n    def _container_as_resource(self, container: \"Container\") -&gt; Dict[str, str]:\n        \"\"\"Convert a container to a resource dictionary\"\"\"\n        return {\n            \"prefect.resource.id\": f\"prefect.docker.container.{container.id}\",\n            \"prefect.resource.name\": container.name,\n        }\n\n    def _emit_container_creation_failed_event(\n        self, configuration: DockerWorkerJobConfiguration\n    ) -&gt; Event:\n        \"\"\"Emit a Prefect event when a docker container fails to be created.\"\"\"\n        return emit_event(\n            event=\"prefect.docker.container.creation-failed\",\n            resource=self._event_resource(),\n            related=self._event_related_resources(configuration=configuration),\n        )\n\n    def _emit_container_status_change_event(\n        self,\n        container: \"Container\",\n        configuration: DockerWorkerJobConfiguration,\n        last_event: Optional[Event] = None,\n    ) -&gt; Event:\n        \"\"\"Emit a Prefect event for a Docker container event.\"\"\"\n        related = self._event_related_resources(configuration=configuration)\n\n        worker_resource = self._event_resource()\n        worker_resource[\"prefect.resource.role\"] = \"worker\"\n        worker_related_resource = RelatedResource(__root__=worker_resource)\n\n        return emit_event(\n            event=f\"prefect.docker.container.{container.status.lower()}\",\n            resource=self._container_as_resource(container),\n            related=related + [worker_related_resource],\n            follows=last_event,\n        )\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorker-functions","title":"Functions","text":""},{"location":"worker/#prefect_docker.worker.DockerWorker.kill_infrastructure","title":"<code>kill_infrastructure</code>  <code>async</code>","text":"<p>Stops a container for a cancelled flow run based on the provided infrastructure PID.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>async def kill_infrastructure(\n    self,\n    infrastructure_pid: str,\n    configuration: DockerWorkerJobConfiguration,\n    grace_seconds: int = 30,\n):\n    \"\"\"\n    Stops a container for a cancelled flow run based on the provided infrastructure\n    PID.\n    \"\"\"\n    docker_client = self._get_client()\n\n    base_url, container_id = self._parse_infrastructure_pid(infrastructure_pid)\n    if docker_client.api.base_url != base_url:\n        raise InfrastructureNotAvailable(\n            \"\".join(\n                [\n                    (\n                        f\"Unable to stop container {container_id!r}: the current\"\n                        \" Docker API \"\n                    ),\n                    (\n                        f\"URL {docker_client.api.base_url!r} does not match the\"\n                        \" expected \"\n                    ),\n                    f\"API base URL {base_url}.\",\n                ]\n            )\n        )\n    await run_sync_in_worker_thread(\n        self._stop_container, container_id, docker_client, grace_seconds\n    )\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorker.run","title":"<code>run</code>  <code>async</code>","text":"<p>Executes a flow run within a Docker container and waits for the flow run to complete.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>async def run(\n    self,\n    flow_run: \"FlowRun\",\n    configuration: BaseJobConfiguration,\n    task_status: Optional[anyio.abc.TaskStatus] = None,\n) -&gt; BaseWorkerResult:\n    \"\"\"\n    Executes a flow run within a Docker container and waits for the flow run\n    to complete.\n    \"\"\"\n    # The `docker` library uses requests instead of an async http library so it must\n    # be run in a thread to avoid blocking the event loop.\n    container, created_event = await run_sync_in_worker_thread(\n        self._create_and_start_container, configuration\n    )\n    container_pid = self._get_infrastructure_pid(container_id=container.id)\n\n    # Mark as started and return the infrastructure id\n    if task_status:\n        task_status.started(container_pid)\n\n    # Monitor the container\n    container = await run_sync_in_worker_thread(\n        self._watch_container_safe, container, configuration, created_event\n    )\n\n    exit_code = container.attrs[\"State\"].get(\"ExitCode\")\n    return DockerWorkerResult(\n        status_code=exit_code if exit_code is not None else -1,\n        identifier=container_pid,\n    )\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorkerJobConfiguration","title":"<code>DockerWorkerJobConfiguration</code>","text":"<p>             Bases: <code>BaseJobConfiguration</code></p> <p>Configuration class used by the Docker worker.</p> <p>An instance of this class is passed to the Docker worker's <code>run</code> method for each flow run. It contains all the information necessary to execute the flow run as a Docker container.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The name to give to created Docker containers.</p> <code>command</code> <p>The command executed in created Docker containers to kick off flow run execution.</p> <code>env</code> <p>The environment variables to set in created Docker containers.</p> <code>labels</code> <p>The labels to set on created Docker containers.</p> <code>image</code> <code>str</code> <p>The image reference of a container image to use for created jobs. If not set, the latest Prefect image will be used.</p> <code>image_pull_policy</code> <code>Optional[Literal['IfNotPresent', 'Always', 'Never']]</code> <p>The image pull policy to use when pulling images.</p> <code>networks</code> <code>List[str]</code> <p>Docker networks that created containers should be connected to.</p> <code>network_mode</code> <code>Optional[str]</code> <p>The network mode for the created containers (e.g. host, bridge). If 'networks' is set, this cannot be set.</p> <code>auto_remove</code> <code>bool</code> <p>If set, containers will be deleted on completion.</p> <code>volumes</code> <code>List[str]</code> <p>Docker volumes that should be mounted in created containers.</p> <code>stream_output</code> <code>bool</code> <p>If set, the output from created containers will be streamed to local standard output.</p> <code>mem_limit</code> <code>Optional[str]</code> <p>Memory limit of created containers. Accepts a value with a unit identifier (e.g. 100000b, 1000k, 128m, 1g.) If a value is given without a unit, bytes are assumed.</p> <code>memswap_limit</code> <code>Optional[str]</code> <p>Total memory (memory + swap), -1 to disable swap. Should only be set if <code>mem_limit</code> is also set. If <code>mem_limit</code> is set, this defaults to allowing the container to use as much swap as memory. For example, if <code>mem_limit</code> is 300m and <code>memswap_limit</code> is not set, containers can use 600m in total of memory and swap.</p> <code>privileged</code> <code>bool</code> <p>Give extended privileges to created containers.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>class DockerWorkerJobConfiguration(BaseJobConfiguration):\n    \"\"\"\n    Configuration class used by the Docker worker.\n\n    An instance of this class is passed to the Docker worker's `run` method\n    for each flow run. It contains all the information necessary to execute the\n    flow run as a Docker container.\n\n    Attributes:\n        name: The name to give to created Docker containers.\n        command: The command executed in created Docker containers to kick off\n            flow run execution.\n        env: The environment variables to set in created Docker containers.\n        labels: The labels to set on created Docker containers.\n        image: The image reference of a container image to use for created jobs.\n            If not set, the latest Prefect image will be used.\n        image_pull_policy: The image pull policy to use when pulling images.\n        networks: Docker networks that created containers should be connected to.\n        network_mode: The network mode for the created containers (e.g. host, bridge).\n            If 'networks' is set, this cannot be set.\n        auto_remove: If set, containers will be deleted on completion.\n        volumes: Docker volumes that should be mounted in created containers.\n        stream_output: If set, the output from created containers will be streamed\n            to local standard output.\n        mem_limit: Memory limit of created containers. Accepts a value\n            with a unit identifier (e.g. 100000b, 1000k, 128m, 1g.) If a value is\n            given without a unit, bytes are assumed.\n        memswap_limit: Total memory (memory + swap), -1 to disable swap. Should only be\n            set if `mem_limit` is also set. If `mem_limit` is set, this defaults to\n            allowing the container to use as much swap as memory. For example, if\n            `mem_limit` is 300m and `memswap_limit` is not set, containers can use\n            600m in total of memory and swap.\n        privileged: Give extended privileges to created containers.\n    \"\"\"\n\n    image: str = Field(\n        default_factory=get_prefect_image_name,\n        description=\"The image reference of a container image to use for created jobs. \"\n        \"If not set, the latest Prefect image will be used.\",\n        example=\"docker.io/prefecthq/prefect:2-latest\",\n    )\n    registry_credentials: Optional[DockerRegistryCredentials] = Field(\n        default=None,\n        description=\"Credentials for logging into a Docker registry to pull\"\n        \" images from.\",\n    )\n    image_pull_policy: Optional[Literal[\"IfNotPresent\", \"Always\", \"Never\"]] = Field(\n        default=None,\n        description=\"The image pull policy to use when pulling images.\",\n    )\n    networks: List[str] = Field(\n        default_factory=list,\n        description=\"Docker networks that created containers should be connected to.\",\n    )\n    network_mode: Optional[str] = Field(\n        default=None,\n        description=(\n            \"The network mode for the created containers (e.g. host, bridge). If\"\n            \" 'networks' is set, this cannot be set.\"\n        ),\n    )\n    auto_remove: bool = Field(\n        default=False,\n        description=\"If set, containers will be deleted on completion.\",\n    )\n    volumes: List[str] = Field(\n        default_factory=list,\n        description=\"A list of volume to mount into created containers.\",\n        example=[\"/my/local/path:/path/in/container\"],\n    )\n    stream_output: bool = Field(\n        default=True,\n        description=(\n            \"If set, the output from created containers will be streamed to local \"\n            \"standard output.\"\n        ),\n    )\n    mem_limit: Optional[str] = Field(\n        default=None,\n        title=\"Memory Limit\",\n        description=(\n            \"Memory limit of created containers. Accepts a value \"\n            \"with a unit identifier (e.g. 100000b, 1000k, 128m, 1g.) \"\n            \"If a value is given without a unit, bytes are assumed.\"\n        ),\n    )\n    memswap_limit: Optional[str] = Field(\n        default=None,\n        title=\"Memory Swap Limit\",\n        description=(\n            \"Total memory (memory + swap), -1 to disable swap. Should only be \"\n            \"set if `mem_limit` is also set. If `mem_limit` is set, this defaults to\"\n            \"allowing the container to use as much swap as memory. For example, if \"\n            \"`mem_limit` is 300m and `memswap_limit` is not set, containers can use \"\n            \"600m in total of memory and swap.\"\n        ),\n    )\n\n    privileged: bool = Field(\n        default=False,\n        description=\"Give extended privileges to created container.\",\n    )\n\n    @validator(\"volumes\")\n    def _validate_volume_format(cls, volumes):\n        \"\"\"Validates that provided volume strings are in the correct format.\"\"\"\n        for volume in volumes:\n            if \":\" not in volume:\n                raise ValueError(\n                    \"Invalid volume specification. \"\n                    f\"Expected format 'path:container_path', but got {volume!r}\"\n                )\n\n        return volumes\n\n    def _convert_labels_to_docker_format(self, labels: Dict[str, str]):\n        \"\"\"Converts labels to the format expected by Docker.\"\"\"\n        labels = labels or {}\n        new_labels = {}\n        for name, value in labels.items():\n            if \"/\" in name:\n                namespace, key = name.split(\"/\", maxsplit=1)\n                new_namespace = \".\".join(reversed(namespace.split(\".\")))\n                new_labels[f\"{new_namespace}.{key}\"] = value\n            else:\n                new_labels[name] = value\n        return new_labels\n\n    def _slugify_container_name(self) -&gt; Optional[str]:\n        \"\"\"\n        Generates a container name to match the configured name, ensuring it is Docker\n        compatible.\n        \"\"\"\n        # Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+` in the end\n        if not self.name:\n            return None\n\n        return (\n            slugify(\n                self.name,\n                lowercase=False,\n                # Docker does not limit length but URL limits apply eventually so\n                # limit the length for safety\n                max_length=250,\n                # Docker allows these characters for container names\n                regex_pattern=r\"[^a-zA-Z0-9_.-]+\",\n            ).lstrip(\n                # Docker does not allow leading underscore, dash, or period\n                \"_-.\"\n            )\n            # Docker does not allow 0 character names so cast to null if the name is\n            # empty after slufification\n            or None\n        )\n\n    def _base_environment(self):\n        \"\"\"\n        If the API URL has been set update the value to ensure connectivity\n        when using a bridge network by updating local connections to use the\n        docker internal host unless the network mode is \"host\" where localhost\n        is available already.\n        \"\"\"\n\n        base_env = super()._base_environment()\n        network_mode = self.get_network_mode()\n        if (\n            \"PREFECT_API_URL\" in base_env\n            and base_env[\"PREFECT_API_URL\"] is not None\n            and network_mode != \"host\"\n        ):\n            base_env[\"PREFECT_API_URL\"] = (\n                base_env[\"PREFECT_API_URL\"]\n                .replace(\"localhost\", \"host.docker.internal\")\n                .replace(\"127.0.0.1\", \"host.docker.internal\")\n            )\n        return base_env\n\n    def prepare_for_flow_run(\n        self,\n        flow_run: \"FlowRun\",\n        deployment: Optional[\"DeploymentResponse\"] = None,\n        flow: Optional[\"Flow\"] = None,\n    ):\n        \"\"\"\n        Prepares the agent for a flow run by setting the image, labels, and name\n        attributes.\n        \"\"\"\n        super().prepare_for_flow_run(flow_run, deployment, flow)\n\n        self.image = self.image or get_prefect_image_name()\n        self.labels = self._convert_labels_to_docker_format(\n            {**self.labels, **CONTAINER_LABELS}\n        )\n        self.name = self._slugify_container_name()\n\n    def get_network_mode(self) -&gt; Optional[str]:\n        \"\"\"\n        Returns the network mode to use for the container based on the configured\n        options and the platform.\n        \"\"\"\n        # User's value takes precedence; this may collide with the incompatible options\n        # mentioned below.\n        if self.network_mode:\n            if sys.platform != \"linux\" and self.network_mode == \"host\":\n                warnings.warn(\n                    f\"{self.network_mode!r} network mode is not supported on platform \"\n                    f\"{sys.platform!r} and may not work as intended.\"\n                )\n            return self.network_mode\n\n        # Network mode is not compatible with networks or ports (we do not support ports\n        # yet though)\n        if self.networks:\n            return None\n\n        # Check for a local API connection\n        api_url = self.env.get(\"PREFECT_API_URL\", PREFECT_API_URL.value())\n\n        if api_url:\n            try:\n                _, netloc, _, _, _, _ = urllib.parse.urlparse(api_url)\n            except Exception as exc:\n                warnings.warn(\n                    f\"Failed to parse host from API URL {api_url!r} with exception: \"\n                    f\"{exc}\\nThe network mode will not be inferred.\"\n                )\n                return None\n\n            host = netloc.split(\":\")[0]\n\n            # If using a locally hosted API, use a host network on linux\n            if sys.platform == \"linux\" and (host == \"127.0.0.1\" or host == \"localhost\"):\n                return \"host\"\n\n        # Default to unset\n        return None\n\n    def get_extra_hosts(self, docker_client) -&gt; Optional[Dict[str, str]]:\n        \"\"\"\n        A host.docker.internal -&gt; host-gateway mapping is necessary for communicating\n        with the API on Linux machines. Docker Desktop on macOS will automatically\n        already have this mapping.\n        \"\"\"\n        if sys.platform == \"linux\" and (\n            # Do not warn if the user has specified a host manually that does not use\n            # a local address\n            \"PREFECT_API_URL\" not in self.env\n            or re.search(\n                \".*(localhost)|(127.0.0.1)|(host.docker.internal).*\",\n                self.env[\"PREFECT_API_URL\"],\n            )\n        ):\n            user_version = packaging.version.parse(\n                format_outlier_version_name(docker_client.version()[\"Version\"])\n            )\n            required_version = packaging.version.parse(\"20.10.0\")\n\n            if user_version &lt; required_version:\n                warnings.warn(\n                    \"`host.docker.internal` could not be automatically resolved to\"\n                    \" your local ip address. This feature is not supported on Docker\"\n                    f\" Engine v{user_version}, upgrade to v{required_version}+ if you\"\n                    \" encounter issues.\"\n                )\n                return {}\n            else:\n                # Compatibility for linux -- https://github.com/docker/cli/issues/2290\n                # Only supported by Docker v20.10.0+ which is our minimum recommend\n                # version\n                return {\"host.docker.internal\": \"host-gateway\"}\n\n    def _determine_image_pull_policy(self) -&gt; ImagePullPolicy:\n        \"\"\"\n        Determine the appropriate image pull policy.\n\n        1. If they specified an image pull policy, use that.\n\n        2. If they did not specify an image pull policy and gave us\n           the \"latest\" tag, use ImagePullPolicy.always.\n\n        3. If they did not specify an image pull policy and did not\n           specify a tag, use ImagePullPolicy.always.\n\n        4. If they did not specify an image pull policy and gave us\n           a tag other than \"latest\", use ImagePullPolicy.if_not_present.\n\n        This logic matches the behavior of Kubernetes.\n        See:https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting\n        \"\"\"\n        if not self.image_pull_policy:\n            _, tag = parse_image_tag(self.image)\n            if tag == \"latest\" or not tag:\n                return ImagePullPolicy.ALWAYS\n            return ImagePullPolicy.IF_NOT_PRESENT\n        return ImagePullPolicy(self.image_pull_policy)\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorkerJobConfiguration-functions","title":"Functions","text":""},{"location":"worker/#prefect_docker.worker.DockerWorkerJobConfiguration.get_extra_hosts","title":"<code>get_extra_hosts</code>","text":"<p>A host.docker.internal -&gt; host-gateway mapping is necessary for communicating with the API on Linux machines. Docker Desktop on macOS will automatically already have this mapping.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>def get_extra_hosts(self, docker_client) -&gt; Optional[Dict[str, str]]:\n    \"\"\"\n    A host.docker.internal -&gt; host-gateway mapping is necessary for communicating\n    with the API on Linux machines. Docker Desktop on macOS will automatically\n    already have this mapping.\n    \"\"\"\n    if sys.platform == \"linux\" and (\n        # Do not warn if the user has specified a host manually that does not use\n        # a local address\n        \"PREFECT_API_URL\" not in self.env\n        or re.search(\n            \".*(localhost)|(127.0.0.1)|(host.docker.internal).*\",\n            self.env[\"PREFECT_API_URL\"],\n        )\n    ):\n        user_version = packaging.version.parse(\n            format_outlier_version_name(docker_client.version()[\"Version\"])\n        )\n        required_version = packaging.version.parse(\"20.10.0\")\n\n        if user_version &lt; required_version:\n            warnings.warn(\n                \"`host.docker.internal` could not be automatically resolved to\"\n                \" your local ip address. This feature is not supported on Docker\"\n                f\" Engine v{user_version}, upgrade to v{required_version}+ if you\"\n                \" encounter issues.\"\n            )\n            return {}\n        else:\n            # Compatibility for linux -- https://github.com/docker/cli/issues/2290\n            # Only supported by Docker v20.10.0+ which is our minimum recommend\n            # version\n            return {\"host.docker.internal\": \"host-gateway\"}\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorkerJobConfiguration.get_network_mode","title":"<code>get_network_mode</code>","text":"<p>Returns the network mode to use for the container based on the configured options and the platform.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>def get_network_mode(self) -&gt; Optional[str]:\n    \"\"\"\n    Returns the network mode to use for the container based on the configured\n    options and the platform.\n    \"\"\"\n    # User's value takes precedence; this may collide with the incompatible options\n    # mentioned below.\n    if self.network_mode:\n        if sys.platform != \"linux\" and self.network_mode == \"host\":\n            warnings.warn(\n                f\"{self.network_mode!r} network mode is not supported on platform \"\n                f\"{sys.platform!r} and may not work as intended.\"\n            )\n        return self.network_mode\n\n    # Network mode is not compatible with networks or ports (we do not support ports\n    # yet though)\n    if self.networks:\n        return None\n\n    # Check for a local API connection\n    api_url = self.env.get(\"PREFECT_API_URL\", PREFECT_API_URL.value())\n\n    if api_url:\n        try:\n            _, netloc, _, _, _, _ = urllib.parse.urlparse(api_url)\n        except Exception as exc:\n            warnings.warn(\n                f\"Failed to parse host from API URL {api_url!r} with exception: \"\n                f\"{exc}\\nThe network mode will not be inferred.\"\n            )\n            return None\n\n        host = netloc.split(\":\")[0]\n\n        # If using a locally hosted API, use a host network on linux\n        if sys.platform == \"linux\" and (host == \"127.0.0.1\" or host == \"localhost\"):\n            return \"host\"\n\n    # Default to unset\n    return None\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorkerJobConfiguration.prepare_for_flow_run","title":"<code>prepare_for_flow_run</code>","text":"<p>Prepares the agent for a flow run by setting the image, labels, and name attributes.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>def prepare_for_flow_run(\n    self,\n    flow_run: \"FlowRun\",\n    deployment: Optional[\"DeploymentResponse\"] = None,\n    flow: Optional[\"Flow\"] = None,\n):\n    \"\"\"\n    Prepares the agent for a flow run by setting the image, labels, and name\n    attributes.\n    \"\"\"\n    super().prepare_for_flow_run(flow_run, deployment, flow)\n\n    self.image = self.image or get_prefect_image_name()\n    self.labels = self._convert_labels_to_docker_format(\n        {**self.labels, **CONTAINER_LABELS}\n    )\n    self.name = self._slugify_container_name()\n</code></pre>"},{"location":"worker/#prefect_docker.worker.DockerWorkerResult","title":"<code>DockerWorkerResult</code>","text":"<p>             Bases: <code>BaseWorkerResult</code></p> <p>Contains information about a completed Docker container</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>class DockerWorkerResult(BaseWorkerResult):\n    \"\"\"Contains information about a completed Docker container\"\"\"\n</code></pre>"},{"location":"worker/#prefect_docker.worker.ImagePullPolicy","title":"<code>ImagePullPolicy</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum representing the image pull policy options for a Docker container.</p> Source code in <code>prefect_docker/worker.py</code> <pre><code>class ImagePullPolicy(enum.Enum):\n    \"\"\"Enum representing the image pull policy options for a Docker container.\"\"\"\n\n    IF_NOT_PRESENT = \"IfNotPresent\"\n    ALWAYS = \"Always\"\n    NEVER = \"Never\"\n</code></pre>"},{"location":"deployments/steps/","title":"Steps","text":""},{"location":"deployments/steps/#prefect_docker.deployments.steps","title":"<code>prefect_docker.deployments.steps</code>","text":"<p>Prefect deployment steps for building and pushing Docker images.</p> <p>These steps can be used in a <code>prefect.yaml</code> file to define the default build steps for a group of deployments, or they can be used to define the build step for a specific deployment.</p> <p>Example</p> <p>Build a Docker image before deploying a flow: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        id: build-image\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n\npush:\n    - prefect_docker.deployments.steps.push_docker_image:\n        requires: prefect-docker\n        image_name: \"{{ build-image.image_name }}\"\n        tag: \"{{ build-image.tag }}\"\n</code></pre></p>"},{"location":"deployments/steps/#prefect_docker.deployments.steps-classes","title":"Classes","text":""},{"location":"deployments/steps/#prefect_docker.deployments.steps.BuildDockerImageResult","title":"<code>BuildDockerImageResult</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>The result of a <code>build_docker_image</code> step.</p> <p>Attributes:</p> Name Type Description <code>image_name</code> <code>str</code> <p>The name of the built image.</p> <code>tag</code> <code>str</code> <p>The tag of the built image.</p> <code>image</code> <code>str</code> <p>The name and tag of the built image.</p> <code>image_id</code> <code>str</code> <p>The ID of the built image.</p> <code>additional_tags</code> <code>Optional[str]</code> <p>The additional tags on the image, in addition to <code>tag</code>.</p> Source code in <code>prefect_docker/deployments/steps.py</code> <pre><code>class BuildDockerImageResult(TypedDict):\n    \"\"\"\n    The result of a `build_docker_image` step.\n\n    Attributes:\n        image_name: The name of the built image.\n        tag: The tag of the built image.\n        image: The name and tag of the built image.\n        image_id: The ID of the built image.\n        additional_tags: The additional tags on the image, in addition to `tag`.\n    \"\"\"\n\n    image_name: str\n    tag: str\n    image: str\n    image_id: str\n    additional_tags: Optional[str]\n</code></pre>"},{"location":"deployments/steps/#prefect_docker.deployments.steps.PushDockerImageResult","title":"<code>PushDockerImageResult</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>The result of a <code>push_docker_image</code> step.</p> <p>Attributes:</p> Name Type Description <code>image_name</code> <code>str</code> <p>The name of the pushed image.</p> <code>tag</code> <code>str</code> <p>The tag of the pushed image.</p> <code>image</code> <code>str</code> <p>The name and tag of the pushed image.</p> <code>additional_tags</code> <code>Optional[str]</code> <p>The additional tags on the image, in addition to <code>tag</code>.</p> Source code in <code>prefect_docker/deployments/steps.py</code> <pre><code>class PushDockerImageResult(TypedDict):\n    \"\"\"\n    The result of a `push_docker_image` step.\n\n    Attributes:\n        image_name: The name of the pushed image.\n        tag: The tag of the pushed image.\n        image: The name and tag of the pushed image.\n        additional_tags: The additional tags on the image, in addition to `tag`.\n    \"\"\"\n\n    image_name: str\n    tag: str\n    image: str\n    additional_tags: Optional[str]\n</code></pre>"},{"location":"deployments/steps/#prefect_docker.deployments.steps-functions","title":"Functions","text":""},{"location":"deployments/steps/#prefect_docker.deployments.steps.build_docker_image","title":"<code>build_docker_image</code>","text":"<p>Builds a Docker image for a Prefect deployment.</p> <p>Can be used within a <code>prefect.yaml</code> file to build a Docker image prior to creating or updating a deployment.</p> <p>Parameters:</p> Name Type Description Default <code>image_name</code> <code>str</code> <p>The name of the Docker image to build, including the registry and repository.</p> required <code>dockerfile</code> <code>str</code> <p>The path to the Dockerfile used to build the image. If \"auto\" is passed, a temporary Dockerfile will be created to build the image.</p> <code>'Dockerfile'</code> <code>tag</code> <code>Optional[str]</code> <p>The tag to apply to the built image.</p> <code>None</code> <code>push</code> <code>bool</code> <code>False</code> <code>credentials</code> <code>Optional[Dict]</code> <p>A dictionary containing the username, password, and URL for the registry to push the image to.</p> <code>None</code> <code>additional_tags</code> <code>Optional[List[str]]</code> <p>Additional tags on the image, in addition to <code>tag</code>, to apply to the built image.</p> <code>None</code> <code>**build_kwargs</code> <p>Additional keyword arguments to pass to Docker when building the image. Available options can be found in the <code>docker-py</code> documentation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BuildDockerImageResult</code> <p>A dictionary containing the image name and tag of the built image.</p> Example <p>Build and push a Docker image prior to creating a deployment: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n</code></pre></p> <p>Build and push a Docker image with multiple tags: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n        additional_tags:\n            - v0.1.0,\n            - dac9ccccedaa55a17916eef14f95cc7bdd3c8199\n</code></pre></p> <p>Build a Docker image using an auto-generated Dockerfile: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n        dockerfile: auto\n        push: false\n</code></pre></p> <p>Build a Docker image for a different platform: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n        dockerfile: Dockerfile\n        push: false\n        platform: amd64\n</code></pre></p> Source code in <code>prefect_docker/deployments/steps.py</code> <pre><code>@deprecated_parameter(\n    \"push\",\n    when=lambda y: y is True,\n    start_date=\"Jun 2023\",\n    help=\"Use the `push_docker_image` step instead.\",\n)\ndef build_docker_image(\n    image_name: str,\n    dockerfile: str = \"Dockerfile\",\n    tag: Optional[str] = None,\n    push: bool = False,\n    credentials: Optional[Dict] = None,\n    additional_tags: Optional[List[str]] = None,\n    **build_kwargs,\n) -&gt; BuildDockerImageResult:\n    \"\"\"\n    Builds a Docker image for a Prefect deployment.\n\n    Can be used within a `prefect.yaml` file to build a Docker\n    image prior to creating or updating a deployment.\n\n    Args:\n        image_name: The name of the Docker image to build, including the registry and\n            repository.\n        dockerfile: The path to the Dockerfile used to build the image. If \"auto\" is\n            passed, a temporary Dockerfile will be created to build the image.\n        tag: The tag to apply to the built image.\n        push: DEPRECATED: Whether to push the built image to the registry.\n        credentials: A dictionary containing the username, password, and URL for the\n            registry to push the image to.\n        additional_tags: Additional tags on the image, in addition to `tag`, to apply to the built image.\n        **build_kwargs: Additional keyword arguments to pass to Docker when building\n            the image. Available options can be found in the [`docker-py`](https://docker-py.readthedocs.io/en/stable/images.html#docker.models.images.ImageCollection.build)\n            documentation.\n\n    Returns:\n        A dictionary containing the image name and tag of the\n            built image.\n\n    Example:\n        Build and push a Docker image prior to creating a deployment:\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n        ```\n\n        Build and push a Docker image with multiple tags:\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n                additional_tags:\n                    - v0.1.0,\n                    - dac9ccccedaa55a17916eef14f95cc7bdd3c8199\n        ```\n\n        Build a Docker image using an auto-generated Dockerfile:\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n                dockerfile: auto\n                push: false\n        ```\n\n\n        Build a Docker image for a different platform:\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n                dockerfile: Dockerfile\n                push: false\n                platform: amd64\n        ```\n    \"\"\"  # noqa\n    auto_build = dockerfile == \"auto\"\n    if auto_build:\n        lines = []\n        base_image = get_prefect_image_name()\n        lines.append(f\"FROM {base_image}\")\n        dir_name = os.path.basename(os.getcwd())\n\n        if Path(\"requirements.txt\").exists():\n            lines.append(\n                f\"COPY requirements.txt /opt/prefect/{dir_name}/requirements.txt\"\n            )\n            lines.append(\n                f\"RUN python -m pip install -r /opt/prefect/{dir_name}/requirements.txt\"\n            )\n\n        lines.append(f\"COPY . /opt/prefect/{dir_name}/\")\n        lines.append(f\"WORKDIR /opt/prefect/{dir_name}/\")\n\n        temp_dockerfile = Path(\"Dockerfile\")\n        if Path(temp_dockerfile).exists():\n            raise ValueError(\"Dockerfile already exists.\")\n\n        with Path(temp_dockerfile).open(\"w\") as f:\n            f.writelines(line + \"\\n\" for line in lines)\n\n        dockerfile = str(temp_dockerfile)\n\n    build_kwargs[\"path\"] = build_kwargs.get(\"path\", os.getcwd())\n    build_kwargs[\"dockerfile\"] = dockerfile\n    build_kwargs[\"pull\"] = build_kwargs.get(\"pull\", True)\n    build_kwargs[\"decode\"] = True\n    build_kwargs[\"labels\"] = {**build_kwargs.get(\"labels\", {}), **IMAGE_LABELS}\n    image_id = None\n\n    with docker_client() as client:\n        try:\n            events = client.api.build(**build_kwargs)\n\n            try:\n                for event in events:\n                    if \"stream\" in event:\n                        sys.stdout.write(event[\"stream\"])\n                        sys.stdout.flush()\n                    elif \"aux\" in event:\n                        image_id = event[\"aux\"][\"ID\"]\n                    elif \"error\" in event:\n                        raise BuildError(event[\"error\"])\n                    elif \"message\" in event:\n                        raise BuildError(event[\"message\"])\n            except docker.errors.APIError as e:\n                raise BuildError(e.explanation) from e\n\n        finally:\n            if auto_build:\n                os.unlink(dockerfile)\n\n        if not isinstance(image_id, str):\n            raise BuildError(\"Docker did not return an image ID for built image.\")\n\n        if not tag:\n            tag = slugify(pendulum.now(\"utc\").isoformat())\n\n        image: Image = client.images.get(image_id)\n        image.tag(repository=image_name, tag=tag)\n\n        additional_tags = additional_tags or []\n        for tag_ in additional_tags:\n            image.tag(repository=image_name, tag=tag_)\n\n        if push:\n            if credentials is not None:\n                client.login(\n                    username=credentials.get(\"username\"),\n                    password=credentials.get(\"password\"),\n                    registry=credentials.get(\"registry_url\"),\n                    reauth=credentials.get(\"reauth\", True),\n                )\n            events = client.api.push(\n                repository=image_name, tag=tag, stream=True, decode=True\n            )\n            try:\n                for event in events:\n                    if \"status\" in event:\n                        sys.stdout.write(event[\"status\"])\n                        if \"progress\" in event:\n                            sys.stdout.write(\" \" + event[\"progress\"])\n                        sys.stdout.write(\"\\n\")\n                        sys.stdout.flush()\n                    elif \"error\" in event:\n                        raise OSError(event[\"error\"])\n            finally:\n                client.api.remove_image(image=f\"{image_name}:{tag}\", noprune=True)\n\n    return {\n        \"image_name\": image_name,\n        \"tag\": tag,\n        \"image\": f\"{image_name}:{tag}\",\n        \"image_id\": image_id,\n        \"additional_tags\": additional_tags,\n    }\n</code></pre>"},{"location":"deployments/steps/#prefect_docker.deployments.steps.push_docker_image","title":"<code>push_docker_image</code>","text":"<p>Push a Docker image to a remote registry.</p> <p>Parameters:</p> Name Type Description Default <code>image_name</code> <code>str</code> <p>The name of the Docker image to push, including the registry and repository.</p> required <code>tag</code> <code>Optional[str]</code> <p>The tag of the Docker image to push.</p> <code>None</code> <code>credentials</code> <code>Optional[Dict]</code> <p>A dictionary containing the username, password, and URL for the registry to push the image to.</p> <code>None</code> <code>additional_tags</code> <code>Optional[List[str]]</code> <p>Additional tags on the image, in addition to <code>tag</code>, to apply to the built image.</p> <code>None</code> <p>Returns:</p> Type Description <code>PushDockerImageResult</code> <p>A dictionary containing the image name and tag of the pushed image.</p> <p>Examples:</p> <p>Build and push a Docker image to a private repository: <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        id: build-image\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n        dockerfile: auto\n\npush:\n    - prefect_docker.deployments.steps.push_docker_image:\n        requires: prefect-docker\n        image_name: \"{{ build-image.image_name }}\"\n        tag: \"{{ build-image.tag }}\"\n        credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n</code></pre></p> <p>Build and push a Docker image to a private repository with multiple tags <pre><code>build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        id: build-image\n        requires: prefect-docker\n        image_name: repo-name/image-name\n        tag: dev\n        dockerfile: auto\n        additional_tags: [\n            v0.1.0,\n            dac9ccccedaa55a17916eef14f95cc7bdd3c8199\n        ]\n\npush:\n    - prefect_docker.deployments.steps.push_docker_image:\n        requires: prefect-docker\n        image_name: \"{{ build-image.image_name }}\"\n        tag: \"{{ build-image.tag }}\"\n        credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n        additional_tags: \"{{ build-image.additional_tags }}\"\n</code></pre></p> Source code in <code>prefect_docker/deployments/steps.py</code> <pre><code>def push_docker_image(\n    image_name: str,\n    tag: Optional[str] = None,\n    credentials: Optional[Dict] = None,\n    additional_tags: Optional[List[str]] = None,\n) -&gt; PushDockerImageResult:\n    \"\"\"\n    Push a Docker image to a remote registry.\n\n    Args:\n        image_name: The name of the Docker image to push, including the registry and\n            repository.\n        tag: The tag of the Docker image to push.\n        credentials: A dictionary containing the username, password, and URL for the\n            registry to push the image to.\n        additional_tags: Additional tags on the image, in addition to `tag`, to apply to the built image.\n\n    Returns:\n        A dictionary containing the image name and tag of the\n            pushed image.\n\n    Examples:\n        Build and push a Docker image to a private repository:\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                id: build-image\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n                dockerfile: auto\n\n        push:\n            - prefect_docker.deployments.steps.push_docker_image:\n                requires: prefect-docker\n                image_name: \"{{ build-image.image_name }}\"\n                tag: \"{{ build-image.tag }}\"\n                credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n        ```\n\n        Build and push a Docker image to a private repository with multiple tags\n        ```yaml\n        build:\n            - prefect_docker.deployments.steps.build_docker_image:\n                id: build-image\n                requires: prefect-docker\n                image_name: repo-name/image-name\n                tag: dev\n                dockerfile: auto\n                additional_tags: [\n                    v0.1.0,\n                    dac9ccccedaa55a17916eef14f95cc7bdd3c8199\n                ]\n\n        push:\n            - prefect_docker.deployments.steps.push_docker_image:\n                requires: prefect-docker\n                image_name: \"{{ build-image.image_name }}\"\n                tag: \"{{ build-image.tag }}\"\n                credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n                additional_tags: \"{{ build-image.additional_tags }}\"\n        ```\n    \"\"\"  # noqa\n    with docker_client() as client:\n        if credentials is not None:\n            client.login(\n                username=credentials.get(\"username\"),\n                password=credentials.get(\"password\"),\n                registry=credentials.get(\"registry_url\"),\n                reauth=credentials.get(\"reauth\", True),\n            )\n        events = list(\n            client.api.push(repository=image_name, tag=tag, stream=True, decode=True)\n        )\n        additional_tags = additional_tags or []\n        for i, tag_ in enumerate(additional_tags):\n            event = list(\n                client.api.push(\n                    repository=image_name, tag=tag_, stream=True, decode=True\n                )\n            )\n            events = events + event\n\n        for event in events:\n            if \"status\" in event:\n                sys.stdout.write(event[\"status\"])\n                if \"progress\" in event:\n                    sys.stdout.write(\" \" + event[\"progress\"])\n                sys.stdout.write(\"\\n\")\n                sys.stdout.flush()\n            elif \"error\" in event:\n                raise OSError(event[\"error\"])\n\n    return {\n        \"image_name\": image_name,\n        \"tag\": tag,\n        \"image\": f\"{image_name}:{tag}\",\n        \"additional_tags\": additional_tags,\n    }\n</code></pre>"}]}